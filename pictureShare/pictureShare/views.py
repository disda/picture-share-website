# -*- coding:utf-8 -*-import flaskfrom pictureShare import appfrom flask import render_template, flash, get_flashed_messages, request, redirect, send_from_directoryfrom pictureShare.models import Image, User, Commentimport loggingimport randomimport hashlibimport stringfrom pictureShare.models import dbfrom flask_login import login_user, logout_user, login_required, current_userimport jsonimport httplibimport osimport uuidimport qiniusdk@app.route ('/')def index():    images = Image.query.order_by ("create_date desc").limit (10).all ()    pictures = []    for image in images:        logging.info (str (image).split (' ')[1])        pictures.append (str (image).split (' ')[1])        # print image.url, image.create_date    return render_template ('index.html', images=images)@app.route ('/profile/<user_id>')  # 每个用户的个人详情页@login_requireddef profile(user_id):    print user_id    my_user_id = str (user_id).split ('_')[1]    my_username = str (user_id).split ('_')[0]    logging.error (my_username + ' ' + my_user_id)    user = User.query.filter_by (username='%s' % my_username).first ()    print user    pageImages = Image.query.filter_by (user_id=user.id).order_by("create_date desc").paginate (page=1, per_page=3)    print pageImages.items    return render_template ('profile.html', user=user, images=pageImages.items, has_next=pageImages.has_next)@app.route ('/profile/images/<int:user_id>/<int:page>/<int:per_page>/')def image_page(user_id, page, per_page):    # return "image_page!"    print user_id, page, per_page    try:        pageImages = Image.query.filter_by (user_id=user_id).paginate (page=page, per_page=3)    except Exception as e:        return "Exception:%s" % e    print "pageImages.items:", pageImages.items    print "pageImages.has_next:", pageImages.has_next    map = {'has_next': pageImages.has_next}    images = []    for image in pageImages.items:        user = User.query.filter_by(id=image.user_id).first()        imageView = {'id': image.id, 'url': image.url, 'comment_count': len (image.comments),'user_name':user.username}        images.append (imageView)    map['images'] = images    print map    return json.dumps (map)    # 前端就是把这个json的借口利用起来@app.route ('/pageDetail/<user_name>/<image_id>')def pageDetail(user_name, image_id):    user = User.query.filter_by (username="%s" % user_name).first ()    image = Image.query.filter_by (id="%d" % int (image_id)).first ()    print user, image    return render_template ('pageDetail.html', user=user, image=image)    # https://images.nowcoder.com/head/849m.png@app.route ('/regloginpage', methods=['get', 'post'])def regloginpage():    # username = request.values.get ('username').strip ()    # password = request.values.get ('password').strip ()    next = request.values.get ('next')    print "regloginpage:", next    message = get_flashed_messages (with_categories=False, category_filter=['reglogin'])  # flash 很多人在用获取信息就是list类型    print "regloginpage:", message    print 1, type (message)    if message:        message = message[0].decode ('utf-8')        print '1:', message        print type (message)        return render_template ('login.html', message=message)    else:        # print message     # 提前把下一个页面的信息添加进去post请求中        return render_template ('login.html', message="", next=next)        # 可以加更多的判断def redirect_with_msg(target, msg, category):    print 'coaegory:', category    if msg is not None:        flash (msg, category=category)        print type (msg)    return redirect (target)# 用户安全机密模块def make_salt(num):    return ''.join (random.choice (string.letters + string.digits) for x in xrange (num))@app.route ('/reg', methods=['get', 'post'])  # 注册函数def reg():    # request.args request.values    username = request.values.get ('username')    password = request.values.get ('password')    next = request.values.get ('next')    print 'reg,next:', next    print type (username), type (password)    print username, password    if str (username) == "" or str (password) == "":        print username, password        return redirect_with_msg ('/regloginpage', u"用户名或密码不能为空".encode ('utf-8'), 'reglogin')    print username, password    # 需求，加入正则表达式对账号和密码进行判断，限定设置账号密码的规则    user = User.query.filter_by (username="%s" % username).first ()    print user    if user is not None:        return redirect_with_msg ('/regloginpage', u"用户名已存在".encode ('utf-8'), 'reglogin')    salt = make_salt (10)    password = hashlib.sha256 (password + salt).hexdigest ()    print "mima:", password, salt    user = User (username, password, salt)    db.session.add (user)    db.session.commit ()    login_user (user)    if str(next) != str(None):        return redirect (next)    return redirect ('/')@app.route ('/login', methods=['get', 'post'])def login():    username = request.values.get ('username')    password = request.values.get ('password')    next = request.values.get ('next')    print 'login_next:', next    print type (username), type (password)    print username, password    if str (username) == "" or str (password) == "":        print 'login:', username, password        return redirect_with_msg ('/regloginpage', u"用户名或密码不能为空".encode ('utf-8'), 'reglogin')    user = User.query.filter_by (username=username).first ()    print user    if user is None:        return redirect_with_msg ('/regloginpage', u"此用户不存在请重新输入".encode ('utf-8'), 'reglogin')    salt = user.salt    print "salt:", user.salt    print "password:", user.password    check_password = hashlib.sha256 (password + salt).hexdigest ()    if check_password == user.password:        login_user (user)        print "next:", next        print type (next)        if str (next) == str (None):            return redirect ('/')        else:            print "进入了next"            return redirect (next)            # 这个人登录成功了，我们一定要进行登记，记录这个用户的一个token值，用于服务器识别这个用户            # 我们要理解http是无状态连接，所以我们的储存一个值让服务器知道是我们            # t可以是一个session也可以是一个cookies中的一个密钥，服务端关联user_id和token之间            # session_id和user_id 关联起来也是可以的            # 设置有效期就是存储cookies就是记住登录，有效期是永久就是github            # 登录过和没有登录过戴token的请求，通过user_id获取用户具体信息    else:        return redirect_with_msg ('/regloginpage', u"密码错误重新输入".encode ('utf-8'), 'reglogin')@app.route ('/logout')def logout():    logout_user ()    return redirect ('/')    # flask_login cookies设置浏览器    # flask_logging    # 单点登录，撞库    # ajax网页不进行刷新返回json格式的数据，服务端，异步借口的形式    # 统一进行管理，统一的接口def save_to_local(file, file_name):    save_dir = app.config['UPLOAD_DIR']    file.save (os.path.join (save_dir, file_name))    return '/images/' + file_name@app.route ('/images/<image_name>')  # 返回图片def view_image(image_name):    return send_from_directory (app.config['UPLOAD_DIR'], image_name)@app.route ('/upload/', methods=["post"])@login_requireddef upload():    print "hello!"    print request.method    try:        raise 'file' in request.files    except Exception as e:        print e    print 1, request.files['file']  # 流文件    print 2, request.files    file = request.files['file']    print request.files    print type (request.files)    file_ext = ""    if file.filename.find ('.') > 0:        file_ext = file.filename.split ('.')[1].strip ().lower ()    if file_ext in app.config["ALLOWED_EXT"]:        print "文件名符合"        file_name = str (uuid.uuid1 ()).replace ('-', '') + '.' + file_ext        # url = save_to_local (file, file_name)        url = qiniusdk.qiniu_upload_file (file, file_name)        print url        if url != None:            print "url符合"            db.session.add (Image (url, current_user.id))            db.session.commit ()            print current_user.username, current_user.id    return redirect ('/profile/%s_%d' % (current_user.username, current_user.id))    # return redirect ('/')@app.route ('/add/comment/', methods={"post"})  # 增加评论def add_comment():    image_id = request.values['image_id']    content = request.values['content']    comment = Comment (content, current_user.id, image_id)    db.sessdion (comment)    db.session.commit ()